<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PaintBall Brasil</title>
    <style>
        /* (mesmo estilo - omitido por brevidade, mas deve ser mantido) */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            border-left: 5px solid #ffdf00;
            z-index: 100;
            pointer-events: none;
            backdrop-filter: blur(5px);
        }
        
        #info h1 {
            margin: 0;
            color: #ffdf00;
            text-shadow: 2px 2px 0 #ff6b6b;
            font-size: 1.8rem;
        }
        
        #controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 50px;
            border: 2px solid #ff6b6b;
            z-index: 100;
            backdrop-filter: blur(5px);
            display: flex;
            gap: 30px;
            font-size: 0.9rem;
        }
        
        .control-key {
            background: #333;
            padding: 4px 10px;
            border-radius: 5px;
            border: 1px solid #ffdf00;
            color: #ffdf00;
            font-weight: bold;
        }
        
        #health-bar {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border-radius: 30px;
            border: 2px solid #ff6b6b;
            z-index: 100;
            min-width: 200px;
        }
        
        #ammo {
            position: absolute;
            bottom: 120px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border-radius: 30px;
            border: 2px solid #ffdf00;
            z-index: 100;
            color: white;
            font-size: 1.2rem;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border: 2px solid #ffdf00;
            border-radius: 50%;
            z-index: 50;
            pointer-events: none;
            box-shadow: 0 0 10px #ff6b6b;
        }
        
        #crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 10px;
            height: 10px;
            background: #ff6b6b;
            border-radius: 50%;
        }
        
        #score {
            display: none;
        }
        
        #debug-info {
            position: absolute;
            bottom: 120px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            color: #0f0;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 14px;
            z-index: 1000;
            border: 1px solid #ffdf00;
            display: none;
        }
        
        #team-stats {
            position: absolute;
            top: 100px;
            right: 20px;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 10px;
            color: white;
            border: 2px solid #ffdf00;
            z-index: 100;
            min-width: 220px;
            backdrop-filter: blur(5px);
        }
        
        .team-green {
            color: #00ff00;
            font-weight: bold;
        }
        
        .team-pink {
            color: #ff6b6b;
            font-weight: bold;
        }
        
        .player-list {
            margin-top: 10px;
            font-size: 14px;
        }
        
        .player-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            padding: 3px 5px;
            border-radius: 3px;
            background: rgba(255,255,255,0.1);
        }

        #pointer-warning {
            position: absolute;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,0,0,0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 50px;
            font-size: 1.2rem;
            z-index: 200;
            display: none;
        }

        #victory-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: #ffdf00;
            padding: 30px 50px;
            border-radius: 20px;
            font-size: 3rem;
            font-weight: bold;
            border: 4px solid #ff6b6b;
            z-index: 300;
            display: none;
            text-align: center;
            box-shadow: 0 0 30px rgba(255,223,0,0.5);
        }

        #restart-button {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: #ff6b6b;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            z-index: 400;
            font-weight: bold;
            border: 2px solid #ffdf00;
            transition: transform 0.2s;
        }

        #restart-button:hover {
            transform: scale(1.1);
            background: #ff4444;
        }

        #death-message {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: #ff6b6b;
            padding: 20px 40px;
            border-radius: 20px;
            font-size: 2rem;
            font-weight: bold;
            border: 2px solid #ffdf00;
            z-index: 350;
            display: none;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="info">
        <h1>üé® PAINTBALL BRASIL</h1>
        <p>Samb√≥dromo da Tinta ‚Ä¢ Verde (voc√™ + 2) vs Rosa (3)</p>
    </div>
    
    <div id="score">
        <span style="color: #009c3b;">üü¢ VERDE: <span id="green-score">0</span></span>
        <span style="color: #ff6b6b;">üî¥ ROSA: <span id="pink-score">0</span></span>
    </div>
    
    <div id="team-stats">
        <div style="display: flex; justify-content: space-between; border-bottom: 1px solid #ffdf00; padding-bottom: 5px;">
            <span class="team-green">üü¢ TIME VERDE (voc√™ + 2)</span>
            <span class="team-pink">üî¥ TIME ROSA (3)</span>
        </div>
        <div class="player-list" id="team-players">
            <!-- Preenchido via JS -->
        </div>
        <div style="margin-top: 10px; text-align: center; font-size: 12px; color: #aaa;">
            Elimine todos os inimigos para vencer
        </div>
    </div>
    
    <div id="health-bar">
        <div style="color: white; margin-bottom: 5px;">‚ù§Ô∏è Z√â DA GARRA (Verde)</div>
        <div style="width: 100%; height: 15px; background: #333; border-radius: 10px; overflow: hidden;">
            <div id="health-fill" style="height: 100%; width: 100%; background: linear-gradient(90deg, #00ff00, #009c3b); border-radius: 10px;"></div>
        </div>
        <div id="player-health-text" style="color: white; font-size: 0.9rem; margin-top: 5px;">Vida: 3</div>
    </div>
    
    <div id="ammo">
        üî´ <span id="ammo-count">10/10</span>
    </div>
    
    <div id="crosshair"></div>
    
    <div id="controls">
        <div><span class="control-key">WASD</span> Andar</div>
        <div><span class="control-key">MOUSE</span> Mirar</div>
        <div><span class="control-key">CLICK</span> Atirar</div>
        <div><span class="control-key">R</span> Recarregar</div>
        <div><span class="control-key">ESPACO</span> Pular</div>
    </div>
    
    <div id="debug-info">
        üéÆ POS: <span id="debug-pos">0, 0, 0</span> | VEL: <span id="debug-vel">0, 0, 0</span><br>
        üèÉ MOV: <span id="debug-move">PARADO</span> | üìç CH√ÉO: <span id="debug-ground">SIM</span>
    </div>

    <div id="pointer-warning">
        ‚ö†Ô∏è Clique na tela para travar o mouse e andar
    </div>

    <div id="victory-message"></div>
    <div id="death-message">üíÄ VOC√ä FOI ELIMINADO üíÄ</div>
    <button id="restart-button">üîÑ Reiniciar Partida</button>

    <!-- Import Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- CONFIGURA√á√ÉO INICIAL ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 30, 70);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.8, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- ILUMINA√á√ÉO ---
        const sunLight = new THREE.DirectionalLight(0xfff5d1, 1.2);
        sunLight.position.set(20, 30, 20);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 70;
        sunLight.shadow.camera.left = -30;
        sunLight.shadow.camera.right = 30;
        sunLight.shadow.camera.top = 30;
        sunLight.shadow.camera.bottom = -30;
        scene.add(sunLight);

        const ambientLight = new THREE.AmbientLight(0x606080, 0.8);
        scene.add(ambientLight);

        // Luz secund√°ria para ilumina√ß√£o suave das sombras
        const fillLight = new THREE.DirectionalLight(0xaaccff, 0.3);
        fillLight.position.set(-15, 10, -10);
        scene.add(fillLight);

        // --- CH√ÉO ---
        const groundGeometry = new THREE.CircleGeometry(40, 64);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x3a6a3a,
            roughness: 0.8,
            metalness: 0.1
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = 0;
        ground.receiveShadow = true;
        scene.add(ground);

        // Grade do samb√≥dromo
        for (let i = -20; i <= 20; i += 2) {
            const lineGeo = new THREE.BoxGeometry(40, 0.05, 0.2);
            const lineMat = new THREE.MeshStandardMaterial({ color: 0xffdf00 });
            const line = new THREE.Mesh(lineGeo, lineMat);
            line.position.set(0, 0.02, i);
            line.receiveShadow = true;
            scene.add(line);
        }

        // --- LISTA DE OBST√ÅCULOS COM FORMAS REAIS ---
        const obstacles = [];
        
        function createBarrel(x, z, color) {
            const group = new THREE.Group();
            
            const barrelGeo = new THREE.CylinderGeometry(0.8, 0.8, 1.5, 8);
            const barrelMat = new THREE.MeshStandardMaterial({ color: color });
            const barrel = new THREE.Mesh(barrelGeo, barrelMat);
            barrel.position.y = 0.75;
            barrel.castShadow = true;
            barrel.receiveShadow = true;
            group.add(barrel);
            
            group.position.set(x, 0, z);
            
            scene.add(group);
            
            obstacles.push({
                type: 'cylinder',
                mesh: group,
                position: new THREE.Vector3(x, 0, z),
                radius: 0.8,
                height: 1.5,
                yMin: 0,
                yMax: 1.5
            });
            
            return group;
        }

        function createCrate(x, z, color) {
            const group = new THREE.Group();
            
            const crateGeo = new THREE.BoxGeometry(1.2, 1.2, 1.2);
            const crateMat = new THREE.MeshStandardMaterial({ color: color });
            const crate = new THREE.Mesh(crateGeo, crateMat);
            crate.position.y = 0.6;
            crate.castShadow = true;
            crate.receiveShadow = true;
            group.add(crate);
            
            group.position.set(x, 0, z);
            
            scene.add(group);
            
            obstacles.push({
                type: 'box',
                mesh: group,
                position: new THREE.Vector3(x, 0, z),
                size: new THREE.Vector3(1.2, 1.2, 1.2),
                yMin: 0,
                yMax: 1.2
            });
            
            return group;
        }

        function createColumn(x, z) {
            const group = new THREE.Group();
            
            const colGeo = new THREE.CylinderGeometry(0.5, 0.5, 3, 8);
            const colMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
            const col = new THREE.Mesh(colGeo, colMat);
            col.position.y = 1.5;
            col.castShadow = true;
            col.receiveShadow = true;
            group.add(col);
            
            group.position.set(x, 0, z);
            
            scene.add(group);
            
            obstacles.push({
                type: 'cylinder',
                mesh: group,
                position: new THREE.Vector3(x, 0, z),
                radius: 0.5,
                height: 3,
                yMin: 0,
                yMax: 3
            });
            
            return group;
        }

        // Criar obst√°culos (barris e caixotes baixos ‚Äî no ch√£o)
        createBarrel(6, 6, 0xff6b6b);
        createBarrel(6, -6, 0x4169E1);
        createBarrel(-6, 6, 0x32CD32);
        createBarrel(-6, -6, 0xffdf00);
        
        createCrate(8, 3, 0x8B4513);
        createCrate(-8, -3, 0x8B4513);
        createCrate(3, 8, 0x654321);
        createCrate(-3, -8, 0x654321);

        // --- ARQUIBANCADAS COM DEGRAUS ---
        function createBleachers(x, z, rotation) {
            const group = new THREE.Group();
            
            for (let i = 0; i < 4; i++) {
                const stepGeo = new THREE.BoxGeometry(5, 0.4, 1.2);
                const stepMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const step = new THREE.Mesh(stepGeo, stepMat);
                step.position.set(0, i * 0.4 + 0.2, i * 1.2 - 2);
                step.castShadow = true;
                step.receiveShadow = true;
                group.add(step);
                
                obstacles.push({
                    type: 'box',
                    mesh: step,
                    position: new THREE.Vector3(x, 0, z).clone().add(
                        new THREE.Vector3(0, i * 0.4 + 0.2, i * 1.2 - 2).applyEuler(new THREE.Euler(0, rotation, 0))
                    ),
                    size: new THREE.Vector3(5, 0.4, 1.2),
                    yMin: i * 0.4,
                    yMax: i * 0.4 + 0.4,
                    rotation: rotation
                });
            }
            
            group.position.set(x, 0, z);
            group.rotation.y = rotation;
            
            scene.add(group);
        }

        createBleachers(15, 0, 0);
        createBleachers(-15, 0, Math.PI);

        // --- BARRICADAS DE SACOS DE AREIA ---
        // Cada barricada √© um conjunto de "sacos" empilhados, colis√£o como box
        function createSandbagBarricade(x, z, rotY = 0, wide = 3, tall = 2) {
            const group = new THREE.Group();
            const bagColor = 0xc8a45a;
            const bagDark  = 0xa07830;
            const bagW = 0.55, bagH = 0.32, bagD = 0.28;
            const cols = wide, rows = tall;

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    // Offset alternado para parecer empilhado
                    const offsetX = (row % 2 === 0 ? 0 : bagW * 0.5) + col * bagW;
                    const offsetY = row * bagH + bagH * 0.5;
                    
                    // Saco principal
                    const bGeo = new THREE.BoxGeometry(bagW * 0.92, bagH * 0.88, bagD * 0.9);
                    const bMat = new THREE.MeshStandardMaterial({
                        color: col % 2 === 0 ? bagColor : bagDark,
                        roughness: 0.95
                    });
                    const bag = new THREE.Mesh(bGeo, bMat);
                    bag.position.set(offsetX - (cols * bagW) / 2 + bagW * 0.5, offsetY, 0);
                    // Pequena rota√ß√£o aleat√≥ria para parecer mais natural
                    bag.rotation.y = (Math.random() - 0.5) * 0.15;
                    bag.rotation.z = (Math.random() - 0.5) * 0.08;
                    bag.castShadow = true;
                    bag.receiveShadow = true;
                    group.add(bag);

                    // Amarra√ß√£o no meio do saco
                    const tieGeo = new THREE.BoxGeometry(0.06, bagH * 0.5, bagD * 1.05);
                    const tieMat = new THREE.MeshStandardMaterial({ color: 0x7a5a20, roughness: 1.0 });
                    const tie = new THREE.Mesh(tieGeo, tieMat);
                    tie.position.set(offsetX - (cols * bagW) / 2 + bagW * 0.5, offsetY, 0);
                    group.add(tie);
                }
            }

            group.position.set(x, 0, z);
            group.rotation.y = rotY;
            scene.add(group);

            // Colis√£o como caixa √∫nica
            const totalW = cols * bagW;
            const totalH = rows * bagH;
            const cos = Math.cos(rotY), sin = Math.sin(rotY);
            const cx = x, cz = z;
            obstacles.push({
                type: 'box',
                mesh: group,
                position: new THREE.Vector3(cx, totalH / 2, cz),
                size: new THREE.Vector3(totalW, totalH, bagD * 1.2),
                yMin: 0,
                yMax: totalH,
                rotY: rotY
            });
        }

        // Barricadas centrais ‚Äî cobertura no meio do mapa
        createSandbagBarricade(0,   2,  0,           6, 5);
        createSandbagBarricade(0,  -2,  Math.PI,     6, 5);
        createSandbagBarricade(4,   0,  Math.PI/2,   5, 5);
        createSandbagBarricade(-4,  0, -Math.PI/2,   5, 5);

        // Barricadas do lado verde (norte)
        createSandbagBarricade(6,   10,  0,           6, 5);
        createSandbagBarricade(-6,  10,  0,           6, 5);
        createSandbagBarricade(0,   12,  Math.PI/2,   5, 5);

        // Barricadas do lado rosa (sul)
        createSandbagBarricade(6,  -10,  0,           6, 5);
        createSandbagBarricade(-6, -10,  0,           6, 5);
        createSandbagBarricade(0,  -12,  Math.PI/2,   5, 5);

        // Barricadas laterais
        createSandbagBarricade(10,  5,  Math.PI/2,   5, 5);
        createSandbagBarricade(10, -5,  Math.PI/2,   5, 5);
        createSandbagBarricade(-10, 5, -Math.PI/2,   5, 5);
        createSandbagBarricade(-10,-5, -Math.PI/2,   5, 5);

        // --- ZONA DE PINTURA (centro) ---
        const zoneTiles = [];
        for (let i = -3; i <= 3; i+=2) {
            for (let j = -3; j <= 3; j+=2) {
                const tileGeo = new THREE.BoxGeometry(1.8, 0.1, 1.8);
                const tileMat = new THREE.MeshStandardMaterial({ 
                    color: 0xffdf00,
                    emissive: 0x332200,
                    transparent: true,
                    opacity: 0.6
                });
                const tile = new THREE.Mesh(tileGeo, tileMat);
                tile.position.set(i, 0.05, j);
                tile.receiveShadow = true;
                scene.add(tile);
                zoneTiles.push(tile);
            }
        }

        // --- √ÅRVORES (com colis√£o) ---
        for (let i = 0; i < 30; i++) {
            const treeGroup = new THREE.Group();
            
            const trunkGeo = new THREE.CylinderGeometry(0.3, 0.4, 2.5);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 1.25;
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            treeGroup.add(trunk);
            
            const leafGeo = new THREE.ConeGeometry(0.8, 1.5, 6);
            const leafMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            const leaf = new THREE.Mesh(leafGeo, leafMat);
            leaf.position.y = 2.5;
            leaf.castShadow = true;
            leaf.receiveShadow = true;
            treeGroup.add(leaf);
            
            const angle = (i / 30) * Math.PI * 2;
            const treeRadius = 22;
            const tx = Math.cos(angle) * treeRadius;
            const tz = Math.sin(angle) * treeRadius;
            treeGroup.position.set(tx, 0, tz);
            
            scene.add(treeGroup);

            // Registrar tronco como obst√°culo cil√≠ndrico
            obstacles.push({
                type: 'cylinder',
                mesh: treeGroup,
                position: new THREE.Vector3(tx, 0, tz),
                radius: 0.4,
                height: 2.5,
                yMin: 0,
                yMax: 2.5
            });
        }

        // ===========================================
        // SISTEMA DE TIMES
        // ===========================================
        let greenScore = 0;
        let pinkScore = 0;
        
        const playerTeam = 'green';
        let playerHealth = 3;
        
        // Jogador vivo ou morto
        const player = {
            mesh: null,
            velocity: new THREE.Vector3(0, 0, 0),
            position: new THREE.Vector3(0, 1.8, 0),
            onGround: false,
            speed: 8,
            radius: 0.5,
            height: 1.8,
            canJump: true,
            jumpCooldown: 0,
            team: 'green',
            alive: true,
            animTime: 0
        };

        const playerGroup = new THREE.Group();
        
        // Torso
        const bodyGeo = new THREE.BoxGeometry(0.7, 0.8, 0.4);
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0x009c3b });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.y = 1.0;
        body.castShadow = true;
        body.receiveShadow = true;
        playerGroup.add(body);

        // Cabe√ßa
        const headGeo = new THREE.SphereGeometry(0.28, 8, 8);
        const headMat = new THREE.MeshStandardMaterial({ color: 0xffccaa });
        const head = new THREE.Mesh(headGeo, headMat);
        head.position.y = 1.65;
        head.castShadow = true;
        playerGroup.add(head);

        const helmetGeo = new THREE.SphereGeometry(0.31, 8, 8);
        const helmetMat = new THREE.MeshStandardMaterial({ color: 0x004d1a, roughness: 0.3 });
        const helmetMesh = new THREE.Mesh(helmetGeo, helmetMat);
        helmetMesh.position.y = 1.68;
        helmetMesh.scale.y = 0.75;
        playerGroup.add(helmetMesh);

        // Pernas
        const pLegGeo = new THREE.BoxGeometry(0.25, 0.7, 0.25);
        const pLegMat = new THREE.MeshStandardMaterial({ color: 0x1a3a1a });
        const pLegL = new THREE.Mesh(pLegGeo, pLegMat);
        pLegL.position.set(-0.2, 0.35, 0);
        pLegL.castShadow = true;
        playerGroup.add(pLegL);
        const pLegR = new THREE.Mesh(pLegGeo, pLegMat);
        pLegR.position.set(0.2, 0.35, 0);
        pLegR.castShadow = true;
        playerGroup.add(pLegR);

        // Bra√ßos
        const pArmGeo = new THREE.BoxGeometry(0.2, 0.65, 0.2);
        const pArmMat = new THREE.MeshStandardMaterial({ color: 0x009c3b });
        const pArmL = new THREE.Mesh(pArmGeo, pArmMat);
        pArmL.position.set(-0.48, 0.95, 0);
        pArmL.castShadow = true;
        playerGroup.add(pArmL);
        const pArmR = new THREE.Mesh(pArmGeo, pArmMat);
        pArmR.position.set(0.48, 0.95, 0);
        pArmR.castShadow = true;
        playerGroup.add(pArmR);

        // Arma de Paintball (marker) ‚Äî presa ao bra√ßo direito
        const markerGroup = new THREE.Group();

        // Corpo principal do marker
        const markerBodyGeo = new THREE.BoxGeometry(0.08, 0.1, 0.55);
        const markerBodyMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.4, metalness: 0.7 });
        const markerBody = new THREE.Mesh(markerBodyGeo, markerBodyMat);
        markerBody.position.set(0, 0, 0);
        markerGroup.add(markerBody);

        // Cano (barrel)
        const barrelGeo = new THREE.CylinderGeometry(0.025, 0.025, 0.55, 8);
        const barrelMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.9, roughness: 0.2 });
        const barrel = new THREE.Mesh(barrelGeo, barrelMat);
        barrel.rotation.x = Math.PI / 2;
        barrel.position.set(0, 0.01, -0.52);
        markerGroup.add(barrel);

        // Cabo (grip)
        const gripGeo = new THREE.BoxGeometry(0.07, 0.2, 0.08);
        const gripMat = new THREE.MeshStandardMaterial({ color: 0x5c3a1e, roughness: 0.9 }); // madeira
        const grip = new THREE.Mesh(gripGeo, gripMat);
        grip.position.set(0, -0.13, 0.1);
        grip.rotation.x = 0.25;
        markerGroup.add(grip);

        // Trigger guard
        const triggerGeo = new THREE.TorusGeometry(0.04, 0.008, 6, 10, Math.PI);
        const triggerMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8 });
        const trigger = new THREE.Mesh(triggerGeo, triggerMat);
        trigger.position.set(0, -0.08, 0.06);
        trigger.rotation.x = Math.PI / 2;
        markerGroup.add(trigger);

        // Hopper (reservat√≥rio de bolas) ‚Äî funil em cima
        const hopperBaseGeo = new THREE.CylinderGeometry(0.1, 0.07, 0.08, 10);
        const hopperMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.3 });
        const hopperBase = new THREE.Mesh(hopperBaseGeo, hopperMat);
        hopperBase.position.set(0, 0.12, -0.05);
        markerGroup.add(hopperBase);

        const hopperTopGeo = new THREE.CylinderGeometry(0.09, 0.1, 0.12, 10);
        const hopperTopMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.4, transparent: true, opacity: 0.85 });
        const hopperTop = new THREE.Mesh(hopperTopGeo, hopperTopMat);
        hopperTop.position.set(0, 0.21, -0.05);
        markerGroup.add(hopperTop);

        // Air tank (tanque de CO2 embaixo)
        const tankGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.3, 10);
        const tankMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.3 });
        const tank = new THREE.Mesh(tankGeo, tankMat);
        tank.rotation.x = Math.PI / 2;
        tank.position.set(0, -0.07, 0.2);
        markerGroup.add(tank);

        // Posicionar o marker na m√£o direita do jogador ‚Äî relativo ao bra√ßo
        // rotation.y = PI faz o cano apontar para frente (-Z do personagem)
        markerGroup.position.set(0.0, -0.35, -0.05);
        markerGroup.rotation.set(0, Math.PI, 0);
        pArmR.add(markerGroup);
        
        scene.add(playerGroup);
        player.mesh = playerGroup;
        player.pLegL = pLegL;
        player.pLegR = pLegR;
        player.pArmL = pArmL;
        player.pArmR = pArmR;

        let npcs = [];

        function updateTeamDisplay() {
            document.getElementById('green-score').textContent = greenScore;
            document.getElementById('pink-score').textContent = pinkScore;
            
            const greenNPCs = npcs.filter(n => n.team === 'green' && n.active);
            const pinkNPCs = npcs.filter(n => n.team === 'pink' && n.active);
            
            let html = '';
            html += `<div class="player-item"><span class="team-green">üü¢ Voc√™ (Verde)</span> <span>‚ù§Ô∏è ${player.alive ? playerHealth : 'üíÄ'}</span></div>`;
            
            greenNPCs.forEach((n, i) => {
                html += `<div class="player-item"><span class="team-green">üü¢ Aliado ${i+1}</span> <span>‚ù§Ô∏è ${n.health}</span></div>`;
            });
            
            pinkNPCs.forEach((n, i) => {
                html += `<div class="player-item"><span class="team-pink">üî¥ Inimigo ${i+1}</span> <span>‚ù§Ô∏è ${n.health}</span></div>`;
            });
            
            document.getElementById('team-players').innerHTML = html;

            checkVictoryCondition();
        }

        // ===========================================
        // NPCs (2 verdes, 3 rosas) - modelos melhorados
        // ===========================================
        function createNPC(x, z, team) {
            const color = team === 'green' ? 0x00aa00 : 0xdd3355;
            const skinColor = 0xffaa88;
            const group = new THREE.Group();

            // Torso
            const torsoGeo = new THREE.BoxGeometry(0.7, 0.8, 0.4);
            const torsoMat = new THREE.MeshStandardMaterial({ color: color });
            const torso = new THREE.Mesh(torsoGeo, torsoMat);
            torso.position.y = 1.0;
            torso.castShadow = true;
            group.add(torso);

            // Cabe√ßa com capacete
            const headGeo = new THREE.SphereGeometry(0.28, 8, 8);
            const headMat = new THREE.MeshStandardMaterial({ color: skinColor });
            const headMesh = new THREE.Mesh(headGeo, headMat);
            headMesh.position.y = 1.65;
            headMesh.castShadow = true;
            group.add(headMesh);

            const helmetGeo = new THREE.SphereGeometry(0.31, 8, 8);
            const helmetMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3 });
            const helmet = new THREE.Mesh(helmetGeo, helmetMat);
            helmet.position.y = 1.68;
            helmet.scale.y = 0.75;
            group.add(helmet);

            // Pernas
            const legGeo = new THREE.BoxGeometry(0.25, 0.7, 0.25);
            const legMat = new THREE.MeshStandardMaterial({ color: 0x333355 });
            const legL = new THREE.Mesh(legGeo, legMat);
            legL.position.set(-0.2, 0.35, 0);
            legL.castShadow = true;
            group.add(legL);
            const legR = new THREE.Mesh(legGeo, legMat);
            legR.position.set(0.2, 0.35, 0);
            legR.castShadow = true;
            group.add(legR);

            // Bra√ßos
            const armGeo = new THREE.BoxGeometry(0.2, 0.65, 0.2);
            const armMat = new THREE.MeshStandardMaterial({ color: color });
            const armL = new THREE.Mesh(armGeo, armMat);
            armL.position.set(-0.48, 0.95, 0);
            armL.castShadow = true;
            group.add(armL);
            const armR = new THREE.Mesh(armGeo, armMat);
            armR.position.set(0.48, 0.95, 0);
            armR.castShadow = true;
            group.add(armR);

            // Marker de paintball ‚Äî m√£o direita do NPC
            const npcMarker = new THREE.Group();

            const npcBodyGeo = new THREE.BoxGeometry(0.07, 0.09, 0.48);
            const npcBodyMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.7 });
            npcMarker.add(new THREE.Mesh(npcBodyGeo, npcBodyMat));

            const npcBarrelGeo = new THREE.CylinderGeometry(0.022, 0.022, 0.48, 8);
            const npcBarrelMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.9 });
            const npcBarrel = new THREE.Mesh(npcBarrelGeo, npcBarrelMat);
            npcBarrel.rotation.x = Math.PI / 2;
            npcBarrel.position.set(0, 0.01, -0.46);
            npcMarker.add(npcBarrel);

            const npcGripGeo = new THREE.BoxGeometry(0.06, 0.17, 0.07);
            const npcGripMat = new THREE.MeshStandardMaterial({ color: 0x5c3a1e, roughness: 0.9 });
            const npcGrip = new THREE.Mesh(npcGripGeo, npcGripMat);
            npcGrip.position.set(0, -0.12, 0.09);
            npcGrip.rotation.x = 0.2;
            npcMarker.add(npcGrip);

            const npcHopperGeo = new THREE.CylinderGeometry(0.085, 0.06, 0.15, 10);
            const npcHopperMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.4 });
            const npcHopper = new THREE.Mesh(npcHopperGeo, npcHopperMat);
            npcHopper.position.set(0, 0.16, -0.04);
            npcMarker.add(npcHopper);

            const npcTankGeo = new THREE.CylinderGeometry(0.035, 0.035, 0.26, 10);
            const npcTankMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8 });
            const npcTank = new THREE.Mesh(npcTankGeo, npcTankMat);
            npcTank.rotation.x = Math.PI / 2;
            npcTank.position.set(0, -0.06, 0.18);
            npcMarker.add(npcTank);

            npcMarker.position.set(0.0, -0.33, -0.05);
            npcMarker.rotation.set(0, Math.PI, 0);
            armR.add(npcMarker);

            group.position.set(x, 0, z);
            scene.add(group);

            const npc = {
                mesh: group,
                legL, legR, armL, armR,
                position: new THREE.Vector3(x, 0, z),
                velocity: new THREE.Vector3(0, 0, 0),
                speed: 4.5,
                radius: 0.5,
                height: 1.8,
                onGround: false,
                team: team,
                timer: 0,
                jumpCooldown: 0,
                stuckTimer: 0,
                lastX: x, lastZ: z,
                health: 3,
                active: true,
                shootCooldown: 0,
                ammo: 10,
                maxAmmo: 10,
                reloadTimer: 0,
                targetEnemy: null,
                animTime: Math.random() * Math.PI * 2
            };

            npcs.push(npc);
            return npc;
        }

        function resetNPCs() {
            npcs.forEach(npc => {
                if (npc.mesh) scene.remove(npc.mesh);
            });
            npcs = [];
            
            // Time verde no lado norte (Z positivo)
            player.position.set(0, 1.8, 14);
            camera.position.copy(player.position);
            player.alive = true;
            player.velocity.set(0, 0, 0);
            player.onGround = false;
            
            createNPC(3, 16, 'green');
            createNPC(-3, 15, 'green');
            
            // Time rosa no lado sul (Z negativo)
            createNPC(-3, -16, 'pink');
            createNPC(3, -15, 'pink');
            createNPC(0, -17, 'pink');
            
            greenScore = 0;
            pinkScore = 0;
            playerHealth = 3;
            document.getElementById('player-health-text').textContent = 'Vida: 3';
            document.getElementById('health-fill').style.width = '100%';
            document.getElementById('death-message').style.display = 'none';
            updateTeamDisplay();
        }

        resetNPCs();

        function showNotification(msg, color = '#ffdf00') {
            const el = document.createElement('div');
            el.textContent = msg;
            el.style.cssText = `position:absolute;top:45%;left:50%;transform:translate(-50%,-50%);
                background:rgba(0,0,0,0.85);color:${color};padding:10px 24px;border-radius:30px;
                font-size:1.1rem;font-weight:bold;z-index:500;pointer-events:none;
                border:2px solid ${color};transition:opacity 0.4s;`;
            document.body.appendChild(el);
            setTimeout(() => { el.style.opacity = '0'; }, 800);
            setTimeout(() => el.remove(), 1200);
        }

        // ===========================================
        // SISTEMA DE TIRO
        // ===========================================
        const projectiles = [];
        let ammo = 10;
        let maxAmmo = 10;
        
        function shoot(position, direction, team, isSpecial = false) {
            // Se o jogador est√° morto, n√£o atira
            if (team === 'green' && !player.alive) return false;
            if (team === 'green' && ammo <= 0) {
                showNotification('Sem muni√ß√£o! Pressione R para recarregar', '#ff4444');
                return false;
            }
            
            if (team === 'green') {
                ammo--;
                document.getElementById('ammo-count').textContent = `${ammo}/${maxAmmo}`;
            }
            
            const bulletGeo = new THREE.SphereGeometry(0.12, 8, 8);
            const bulletMat = new THREE.MeshStandardMaterial({ 
                color: isSpecial ? 0xffdf00 : (team === 'green' ? 0x00ff00 : 0xff6b6b),
                emissive: isSpecial ? 0x332200 : 0x220000
            });
            const bullet = new THREE.Mesh(bulletGeo, bulletMat);
            
            bullet.position.copy(position);
            bullet.position.addScaledVector(direction, 1);
            
            bullet.castShadow = true;
            scene.add(bullet);
            
            const velocity = direction.clone().multiplyScalar(25);
            
            projectiles.push({
                mesh: bullet,
                velocity: velocity,
                life: 150,
                damage: 100,
                isSpecial: isSpecial,
                shooterTeam: team,
                prevPos: bullet.position.clone(),
                radius: 0.12
            });
            
            return true;
        }

        function playerShoot(isSpecial = false) {
            if (!player.alive) return; // morto n√£o atira
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            shoot(camera.position, direction, 'green', isSpecial);
            
            const splatter = document.createElement('div');
            splatter.style.position = 'absolute';
            splatter.style.width = '100px';
            splatter.style.height = '100px';
            splatter.style.background = `radial-gradient(circle, ${isSpecial ? '#ffdf00' : '#ff6b6b'}, transparent)`;
            splatter.style.left = '50%';
            splatter.style.top = '50%';
            splatter.style.transform = 'translate(-50%, -50%) scale(0)';
            splatter.style.borderRadius = '50%';
            splatter.style.transition = 'transform 0.2s';
            splatter.style.pointerEvents = 'none';
            splatter.style.zIndex = '1000';
            document.body.appendChild(splatter);
            
            setTimeout(() => {
                splatter.style.transform = 'translate(-50%, -50%) scale(3)';
            }, 10);
            
            setTimeout(() => {
                splatter.remove();
            }, 200);
        }

        // --- CONTROLES ---
        const moveState = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            jump: false
        };

        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'KeyW': moveState.forward = true; break;
                case 'KeyS': moveState.backward = true; break;
                case 'KeyA': moveState.left = true; break;
                case 'KeyD': moveState.right = true; break;
                case 'Space': 
                    moveState.jump = true;
                    e.preventDefault();
                    break;
                case 'KeyR':
                    if (player.alive) {
                        ammo = maxAmmo;
                        document.getElementById('ammo-count').textContent = `${ammo}/${maxAmmo}`;
                    }
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': moveState.forward = false; break;
                case 'KeyS': moveState.backward = false; break;
                case 'KeyA': moveState.left = false; break;
                case 'KeyD': moveState.right = false; break;
                case 'Space': moveState.jump = false; break;
            }
        });

        let mouseSensitivity = 0.002;
        let pitch = 0;
        let yaw = 0;

        document.addEventListener('mousemove', (e) => {
            if (pointerLocked && player.alive) {
                yaw -= e.movementX * mouseSensitivity;
                pitch -= e.movementY * mouseSensitivity;
                pitch = Math.max(-Math.PI/2.5, Math.min(Math.PI/2.5, pitch));
                
                camera.rotation.order = 'YXZ';
                camera.rotation.y = yaw;
                camera.rotation.x = pitch;
            }
        });

        let pointerLocked = false;
        document.addEventListener('pointerlockchange', () => {
            pointerLocked = !!document.pointerLockElement;
        });

        renderer.domElement.addEventListener('click', () => {
            if (!pointerLocked) {
                renderer.domElement.requestPointerLock();
                // N√ÉO atirar neste clique ‚Äî ele √© s√≥ para travar o mouse
            } else if (player.alive) {
                playerShoot(false);
            }
        });

        renderer.domElement.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (pointerLocked && player.alive) {
                playerShoot(true);
            }
        });

        setInterval(() => {
            const warning = document.getElementById('pointer-warning');
            warning.style.display = pointerLocked ? 'none' : 'block';
        }, 1000);

        // ===========================================
        // F√çSICA DO JOGADOR (s√≥ executa se vivo)
        // ===========================================
        // Returns push-out vector if colliding, or null if free
        function getPlayerPushOut(pos) {
            const playerMinY = pos.y - player.height;
            const playerMaxY = pos.y;
            if (playerMinY < 0) return new THREE.Vector3(0, -playerMinY, 0);
            
            for (let obs of obstacles) {
                if (obs.type === 'cylinder') {
                    if (playerMaxY <= obs.yMin || playerMinY >= obs.yMax) continue;
                    const dx = pos.x - obs.position.x;
                    const dz = pos.z - obs.position.z;
                    const dist = Math.sqrt(dx*dx + dz*dz);
                    const minDist = player.radius + obs.radius;
                    if (dist < minDist) {
                        const overlap = minDist - dist;
                        if (dist > 0.001) {
                            return new THREE.Vector3((dx/dist)*overlap, 0, (dz/dist)*overlap);
                        } else {
                            return new THREE.Vector3(overlap, 0, 0);
                        }
                    }
                } else if (obs.type === 'box') {
                    if (playerMaxY <= obs.yMin || playerMinY >= obs.yMax) continue;
                    const halfX = obs.size.x / 2 + player.radius;
                    const halfZ = obs.size.z / 2 + player.radius;
                    const dx = pos.x - obs.position.x;
                    const dz = pos.z - obs.position.z;
                    const overlapX = halfX - Math.abs(dx);
                    const overlapZ = halfZ - Math.abs(dz);
                    if (overlapX > 0 && overlapZ > 0) {
                        if (overlapX < overlapZ) {
                            return new THREE.Vector3(Math.sign(dx)*overlapX, 0, 0);
                        } else {
                            return new THREE.Vector3(0, 0, Math.sign(dz)*overlapZ);
                        }
                    }
                }
            }
            return null;
        }

        function playerCollides(pos) {
            return getPlayerPushOut(pos) !== null;
        }

        function tryMoveHorizontal(deltaX, deltaZ) {
            const newPos = player.position.clone();
            newPos.x += deltaX;
            newPos.z += deltaZ;
            
            // Resolve collisions with push-out (up to 5 iterations)
            for (let iter = 0; iter < 5; iter++) {
                const push = getPlayerPushOut(newPos);
                if (!push) {
                    player.position.x = newPos.x;
                    player.position.z = newPos.z;
                    return true;
                }
                if (push.y > 0) {
                    // Only floor push ‚Äî position is fine horizontally
                    player.position.x = newPos.x;
                    player.position.z = newPos.z;
                    return true;
                }
                newPos.x += push.x;
                newPos.z += push.z;
            }
            
            // Try step-up
            const stepHeight = 0.5;
            for (let yOffset = 0.1; yOffset <= stepHeight; yOffset += 0.1) {
                const testPos = player.position.clone();
                testPos.x += deltaX;
                testPos.z += deltaZ;
                testPos.y += yOffset;
                if (!playerCollides(testPos)) {
                    player.position.copy(testPos);
                    return true;
                }
            }
            return false;
        }

        function applyGravity(delta) {
            const oldY = player.position.y;
            player.position.y += player.velocity.y * delta;
            
            if (playerCollides(player.position)) {
                if (player.velocity.y < 0) {
                    let low = Math.min(oldY, player.position.y);
                    let high = oldY;
                    let bestY = oldY;
                    for (let step = 0; step < 8; step++) {
                        let mid = (low + high) / 2;
                        let testPos = player.position.clone();
                        testPos.y = mid;
                        if (!playerCollides(testPos)) {
                            bestY = mid;
                            low = mid;
                        } else {
                            high = mid;
                        }
                    }
                    player.position.y = bestY;
                    player.velocity.y = 0;
                    player.onGround = true;
                } else {
                    player.position.y = oldY;
                    player.velocity.y = 0;
                }
            } else {
                if (player.position.y - player.height <= 0) {
                    player.position.y = player.height;
                    player.velocity.y = 0;
                    player.onGround = true;
                } else {
                    player.onGround = false;
                }
            }
        }

        function updatePlayer(delta) {
            if (!player.alive) return; // morto n√£o se move
            
            player.velocity.y -= 15.0 * delta;
            
            if (player.jumpCooldown > 0) {
                player.jumpCooldown -= delta;
            }
            
            if (moveState.jump && player.onGround && player.jumpCooldown <= 0) {
                player.velocity.y = 7.5;
                player.onGround = false;
                player.jumpCooldown = 0.3;
            }
            
            if (document.pointerLockElement) {
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                
                forward.y = 0;
                right.y = 0;
                
                if (forward.length() > 0) forward.normalize();
                if (right.length() > 0) right.normalize();
                
                const moveDir = new THREE.Vector3(0, 0, 0);
                
                if (moveState.forward) moveDir.add(forward);
                if (moveState.backward) moveDir.sub(forward);
                if (moveState.right) moveDir.add(right);
                if (moveState.left) moveDir.sub(right);
                
                if (moveDir.length() > 0) {
                    moveDir.normalize();
                    const targetVelX = moveDir.x * player.speed;
                    const targetVelZ = moveDir.z * player.speed;
                    player.velocity.x += (targetVelX - player.velocity.x) * 8 * delta;
                    player.velocity.z += (targetVelZ - player.velocity.z) * 8 * delta;
                    document.getElementById('debug-move').textContent = 'ANDANDO';
                } else {
                    player.velocity.x *= 0.9;
                    player.velocity.z *= 0.9;
                    if (Math.abs(player.velocity.x) < 0.01) player.velocity.x = 0;
                    if (Math.abs(player.velocity.z) < 0.01) player.velocity.z = 0;
                    document.getElementById('debug-move').textContent = 'PARADO';
                }
            }
            
            const moveX = player.velocity.x * delta;
            const moveZ = player.velocity.z * delta;
            if (moveX !== 0) tryMoveHorizontal(moveX, 0);
            if (moveZ !== 0) tryMoveHorizontal(0, moveZ);
            
            applyGravity(delta);
            
            if (Math.abs(player.position.x) > 19) {
                player.position.x = Math.sign(player.position.x) * 19;
                player.velocity.x = 0;
            }
            if (Math.abs(player.position.z) > 19) {
                player.position.z = Math.sign(player.position.z) * 19;
                player.velocity.z = 0;
            }
            
            camera.position.copy(player.position);
            
            if (player.mesh) {
                player.mesh.position.copy(player.position);
                player.mesh.position.y = 0;
                
                const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                direction.y = 0;
                if (direction.length() > 0) {
                    player.mesh.rotation.y = Math.atan2(direction.x, direction.z);
                }

                // Anima√ß√£o de caminhada
                const isMoving = Math.abs(player.velocity.x) + Math.abs(player.velocity.z) > 0.5;
                if (isMoving && player.onGround) {
                    player.animTime += 8 * 0.016;
                } else if (!player.onGround) {
                    player.animTime += 2 * 0.016;
                }
                const swing = isMoving ? Math.sin(player.animTime) * 0.5 : 0;
                if (player.pLegL) {
                    player.pLegL.rotation.x = swing;
                    player.pLegR.rotation.x = -swing;
                    player.pArmL.rotation.x = -swing * 0.6;
                    // Bra√ßo direito sempre levantado segurando o marker
                    player.pArmR.rotation.x = -Math.PI * 0.30;
                }
            }
            
            document.getElementById('debug-pos').textContent = 
                `${player.position.x.toFixed(1)}, ${player.position.y.toFixed(1)}, ${player.position.z.toFixed(1)}`;
            document.getElementById('debug-vel').textContent = 
                `${player.velocity.x.toFixed(1)}, ${player.velocity.y.toFixed(1)}, ${player.velocity.z.toFixed(1)}`;
            document.getElementById('debug-ground').textContent = player.onGround ? 'SIM' : 'N√ÉO';
        }

        // --- F√çSICA DOS NPCs: push-out 3D + gravidade ---
        function applyNPCGravity(npc, delta) {
            npc.velocity.y -= 18.0 * delta;
            const oldY = npc.position.y;
            npc.position.y += npc.velocity.y * delta;

            // Ch√£o
            if (npc.position.y < 0) {
                npc.position.y = 0;
                npc.velocity.y = 0;
                npc.onGround = true;
            } else {
                // Verificar se est√° em cima de obst√°culo (box tops)
                let landed = false;
                for (let obs of obstacles) {
                    if (obs.type === 'box') {
                        const halfX = obs.size.x / 2 + npc.radius;
                        const halfZ = obs.size.z / 2 + npc.radius;
                        const dx = Math.abs(npc.position.x - obs.position.x);
                        const dz = Math.abs(npc.position.z - obs.position.z);
                        if (dx < halfX && dz < halfZ) {
                            if (oldY >= obs.yMax && npc.position.y < obs.yMax) {
                                npc.position.y = obs.yMax;
                                npc.velocity.y = 0;
                                npc.onGround = true;
                                landed = true;
                                break;
                            }
                        }
                    }
                }
                if (!landed) {
                    npc.onGround = npc.position.y <= 0.001;
                }
            }
        }

        // --- ATUALIZAR NPCs com IA melhorada, gravidade e pulo ---
        function updateNPCs(delta) {
            for (let npc of npcs) {
                if (!npc.active) continue;
                if (npc.shootCooldown > 0) npc.shootCooldown -= delta;
                if (npc.jumpCooldown > 0) npc.jumpCooldown -= delta;
            }

            // Determinar alvos
            for (let npc of npcs) {
                if (!npc.active) continue;

                let enemies = [];
                if (npc.team === 'green') {
                    npcs.forEach(other => {
                        if (other.active && other.team === 'pink') enemies.push(other);
                    });
                } else {
                    npcs.forEach(other => {
                        if (other.active && other.team === 'green') enemies.push(other);
                    });
                    if (player.alive) {
                        enemies.push({ position: player.position, team: 'green', radius: player.radius, isPlayer: true });
                    }
                }

                let closestEnemy = null;
                let closestDist = Infinity;
                for (let enemy of enemies) {
                    const dist = npc.position.distanceTo(enemy.position);
                    if (dist < closestDist && dist < 30) {
                        closestDist = dist;
                        closestEnemy = enemy;
                    }
                }
                npc.targetEnemy = closestEnemy;
            }

            // Movimento + gravidade + pulo
            for (let npc of npcs) {
                if (!npc.active) continue;

                // --- STEERING: dire√ß√£o desejada ---
                let desiredDir = new THREE.Vector3(0, 0, 0);

                if (npc.targetEnemy) {
                    const toEnemy = new THREE.Vector3().subVectors(npc.targetEnemy.position, npc.position);
                    toEnemy.y = 0;
                    const distH = toEnemy.length();
                    if (distH > 1.5) desiredDir.copy(toEnemy.normalize());
                } else {
                    npc.timer += delta;
                    if (npc.timer > 2.5 || npc.desiredDir === undefined) {
                        npc.timer = 0;
                        const angle = Math.random() * Math.PI * 2;
                        npc.desiredDir = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle));
                    }
                    desiredDir.copy(npc.desiredDir);
                }

                // --- DESVIO DE OBST√ÅCULOS (obstacle avoidance steering) ---
                if (desiredDir.length() > 0.01) {
                    const ahead = 1.8;          // dist√¢ncia de "vis√£o √† frente"
                    const sideProbe = 1.0;       // dist√¢ncia lateral do probe
                    const probeRadius = npc.radius + 0.15;

                    // Probe central (√† frente)
                    const frontProbe = npc.position.clone().addScaledVector(desiredDir, ahead);
                    const frontBlocked = getNPCPushOut(frontProbe, probeRadius) !== null;

                    if (frontBlocked) {
                        // Calcular perpendicular √† dire√ß√£o desejada
                        const perp = new THREE.Vector3(-desiredDir.z, 0, desiredDir.x);

                        // Probes laterais
                        const leftProbe  = frontProbe.clone().addScaledVector(perp,  sideProbe);
                        const rightProbe = frontProbe.clone().addScaledVector(perp, -sideProbe);

                        const leftBlocked  = getNPCPushOut(leftProbe,  probeRadius) !== null;
                        const rightBlocked = getNPCPushOut(rightProbe, probeRadius) !== null;

                        if (!leftBlocked && rightBlocked) {
                            // Desviar para a esquerda
                            desiredDir.addScaledVector(perp,  2.5).normalize();
                        } else if (!rightBlocked && leftBlocked) {
                            // Desviar para a direita
                            desiredDir.addScaledVector(perp, -2.5).normalize();
                        } else if (!leftBlocked && !rightBlocked) {
                            // Ambos livres ‚Äî preferir o lado mais pr√≥ximo do destino
                            const bias = npc.stuckBias || 1;
                            desiredDir.addScaledVector(perp, bias * 2.0).normalize();
                        } else {
                            // Ambos bloqueados ‚Äî recuar e escolher nova dire√ß√£o aleat√≥ria
                            const angle = Math.random() * Math.PI * 2;
                            desiredDir.set(Math.sin(angle), 0, Math.cos(angle));
                            npc.desiredDir = desiredDir.clone();
                            npc.stuckBias = (npc.stuckBias || 1) * -1; // alternar lado
                        }
                    } else {
                        npc.stuckBias = 1; // resetar bias quando caminho livre
                    }
                }

                // Aplicar dire√ß√£o desejada √† velocidade
                if (desiredDir.length() > 0.01) {
                    const targetSpeed = npc.speed;
                    npc.velocity.x += (desiredDir.x * targetSpeed - npc.velocity.x) * 10 * delta;
                    npc.velocity.z += (desiredDir.z * targetSpeed - npc.velocity.z) * 10 * delta;
                } else {
                    npc.velocity.x *= 0.85;
                    npc.velocity.z *= 0.85;
                }

                // --- DETEC√á√ÉO DE TRAVADO (fallback) ---
                const movedDist = Math.sqrt(
                    (npc.position.x - npc.lastX) ** 2 + (npc.position.z - npc.lastZ) ** 2
                );
                npc.stuckTimer += delta;
                if (npc.stuckTimer > 0.6) {
                    if (movedDist < 0.08 && (Math.abs(npc.velocity.x) + Math.abs(npc.velocity.z)) > 0.3) {
                        // For√ßar nova dire√ß√£o aleat√≥ria
                        const angle = Math.random() * Math.PI * 2;
                        npc.desiredDir = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle));
                        npc.velocity.x = npc.desiredDir.x * npc.speed * 0.6;
                        npc.velocity.z = npc.desiredDir.z * npc.speed * 0.6;
                        // Tentar pular se for barricada baixa
                        if (npc.onGround && npc.jumpCooldown <= 0) {
                            npc.velocity.y = 6.0;
                            npc.onGround = false;
                            npc.jumpCooldown = 1.2;
                        }
                    }
                    npc.stuckTimer = 0;
                    npc.lastX = npc.position.x;
                    npc.lastZ = npc.position.z;
                }

                // Pulo para alcan√ßar inimigo em plataforma elevada
                if (npc.targetEnemy && npc.onGround && npc.jumpCooldown <= 0) {
                    const heightDiff = npc.targetEnemy.position.y - npc.position.y;
                    if (heightDiff > 0.8 && npc.position.distanceTo(npc.targetEnemy.position) < 5) {
                        npc.velocity.y = 7.5;
                        npc.onGround = false;
                        npc.jumpCooldown = 1.5;
                    }
                }

                // Mover horizontalmente com push-out
                const dx = npc.velocity.x * delta;
                const dz = npc.velocity.z * delta;
                npc.position.x += dx;
                npc.position.z += dz;

                // Boundary
                if (Math.abs(npc.position.x) > 18) {
                    npc.position.x = Math.sign(npc.position.x) * 18;
                    npc.velocity.x *= -0.5;
                }
                if (Math.abs(npc.position.z) > 18) {
                    npc.position.z = Math.sign(npc.position.z) * 18;
                    npc.velocity.z *= -0.5;
                }

                // Push-out horizontal de obst√°culos
                for (let iter = 0; iter < 5; iter++) {
                    const push = getNPCPushOut(npc.position, npc.radius);
                    if (!push) break;
                    npc.position.x += push.x;
                    npc.position.z += push.z;
                    if (Math.abs(push.x) > Math.abs(push.z)) {
                        npc.velocity.x = Math.sign(push.x) * Math.abs(npc.velocity.x) * 0.3;
                    } else {
                        npc.velocity.z = Math.sign(push.z) * Math.abs(npc.velocity.z) * 0.3;
                    }
                }

                // Gravidade e aterrissagem
                applyNPCGravity(npc, delta);

                // Atualizar mesh
                npc.mesh.position.copy(npc.position);

                // Rota√ß√£o
                if (npc.targetEnemy) {
                    const dir = new THREE.Vector3().subVectors(npc.targetEnemy.position, npc.position).normalize();
                    npc.mesh.rotation.y = Math.atan2(dir.x, dir.z);
                } else {
                    const horizSpeed = Math.sqrt(npc.velocity.x**2 + npc.velocity.z**2);
                    if (horizSpeed > 0.3) {
                        npc.mesh.rotation.y = Math.atan2(npc.velocity.x, npc.velocity.z);
                    }
                }

                // Anima√ß√£o de pernas/bra√ßos
                const horizSpeed2 = Math.sqrt(npc.velocity.x**2 + npc.velocity.z**2);
                if (horizSpeed2 > 0.3 && npc.onGround) {
                    npc.animTime += 8 * delta;
                } else {
                    npc.animTime += 1 * delta;
                }
                const swing = (horizSpeed2 > 0.3 && npc.onGround) ? Math.sin(npc.animTime) * 0.5 : 0;
                if (npc.legL) {
                    npc.legL.rotation.x = swing;
                    npc.legR.rotation.x = -swing;
                    npc.armL.rotation.x = -swing * 0.5;
                    // Bra√ßo direito: apontado para frente quando tem alvo
                    if (npc.targetEnemy) {
                        npc.armR.rotation.x = -Math.PI * 0.35; // segurando arma apontada
                    } else {
                        npc.armR.rotation.x = swing * 0.5;
                    }
                }
            }

            // Colis√£o entre NPCs (2D)
            for (let iter = 0; iter < 4; iter++) {
                for (let i = 0; i < npcs.length; i++) {
                    const npcA = npcs[i];
                    if (!npcA.active) continue;
                    for (let j = i + 1; j < npcs.length; j++) {
                        const npcB = npcs[j];
                        if (!npcB.active) continue;
                        const dx = npcA.position.x - npcB.position.x;
                        const dz = npcA.position.z - npcB.position.z;
                        const dist = Math.sqrt(dx*dx + dz*dz);
                        const minDist = npcA.radius + npcB.radius;
                        if (dist < minDist && dist > 0.001) {
                            const overlap = (minDist - dist) * 0.5;
                            npcA.position.x += (dx/dist)*overlap;
                            npcA.position.z += (dz/dist)*overlap;
                            npcB.position.x -= (dx/dist)*overlap;
                            npcB.position.z -= (dz/dist)*overlap;
                            npcA.mesh.position.copy(npcA.position);
                            npcB.mesh.position.copy(npcB.position);
                        }
                    }
                }
            }

            // Colis√£o jogador-NPC
            if (player.alive) {
                for (let npc of npcs) {
                    if (!npc.active) continue;
                    const dx = player.position.x - npc.position.x;
                    const dz = player.position.z - npc.position.z;
                    const dist = Math.sqrt(dx*dx + dz*dz);
                    const minDist = player.radius + npc.radius;
                    if (dist < minDist && dist > 0.001) {
                        const overlap = minDist - dist;
                        player.position.x += (dx/dist)*overlap*0.5;
                        player.position.z += (dz/dist)*overlap*0.5;
                        npc.position.x -= (dx/dist)*overlap*0.5;
                        npc.position.z -= (dz/dist)*overlap*0.5;
                        npc.mesh.position.copy(npc.position);
                    }
                }
            }

            // Tiros dos NPCs ‚Äî muni√ß√£o individual + recarga autom√°tica
            for (let npc of npcs) {
                if (!npc.active) continue;

                // Recarga autom√°tica
                if (npc.ammo <= 0) {
                    npc.reloadTimer += delta;
                    if (npc.reloadTimer >= 1.5) {
                        npc.ammo = npc.maxAmmo;
                        npc.reloadTimer = 0;
                    }
                    continue; // sem bala, n√£o atira
                }

                if (npc.shootCooldown > 0 || !npc.targetEnemy) continue;
                const distToEnemy = npc.position.distanceTo(npc.targetEnemy.position);
                if (distToEnemy < 25 && hasLineOfSight(npc.position, npc.targetEnemy.position)) {
                    const direction = new THREE.Vector3().subVectors(
                        npc.targetEnemy.position.clone().add(new THREE.Vector3(0, 0.9, 0)),
                        npc.position.clone().add(new THREE.Vector3(0, 1.2, 0))
                    ).normalize();
                    direction.x += (Math.random() - 0.5) * 0.12;
                    direction.z += (Math.random() - 0.5) * 0.12;
                    direction.normalize();
                    const shootPos = npc.position.clone().add(new THREE.Vector3(0, 1.2, 0));
                    // Disparar usando a fun√ß√£o gen√©rica (sem checar ammo global)
                    const bulletGeo = new THREE.SphereGeometry(0.12, 8, 8);
                    const bulletMat = new THREE.MeshStandardMaterial({
                        color: npc.team === 'green' ? 0x00ff00 : 0xff6b6b,
                        emissive: 0x220000
                    });
                    const bullet = new THREE.Mesh(bulletGeo, bulletMat);
                    bullet.position.copy(shootPos);
                    bullet.position.addScaledVector(direction, 1);
                    bullet.castShadow = true;
                    scene.add(bullet);
                    projectiles.push({
                        mesh: bullet,
                        velocity: direction.clone().multiplyScalar(25),
                        life: 150,
                        damage: 100,
                        isSpecial: false,
                        shooterTeam: npc.team,
                        prevPos: bullet.position.clone(),
                        radius: 0.12
                    });
                    npc.ammo--;
                    npc.shootCooldown = 0.25 + Math.random() * 0.15; // cad√™ncia mais r√°pida
                    if (npc.ammo <= 0) npc.reloadTimer = 0; // inicia recarga
                }
            }
        }

        // Returns 2D push-out vector for a circle at (position) with given radius against all obstacles
        function getNPCPushOut(position, radius) {
            for (let obs of obstacles) {
                if (obs.type === 'cylinder') {
                    const dx = position.x - obs.position.x;
                    const dz = position.z - obs.position.z;
                    const dist = Math.sqrt(dx*dx + dz*dz);
                    const minDist = radius + obs.radius;
                    if (dist < minDist) {
                        const overlap = minDist - dist;
                        if (dist > 0.001) {
                            return new THREE.Vector3((dx/dist)*overlap, 0, (dz/dist)*overlap);
                        } else {
                            return new THREE.Vector3(overlap, 0, 0);
                        }
                    }
                } else if (obs.type === 'box') {
                    const closestX = Math.max(obs.position.x - obs.size.x/2, Math.min(position.x, obs.position.x + obs.size.x/2));
                    const closestZ = Math.max(obs.position.z - obs.size.z/2, Math.min(position.z, obs.position.z + obs.size.z/2));
                    const dx = position.x - closestX;
                    const dz = position.z - closestZ;
                    const dist = Math.sqrt(dx*dx + dz*dz);
                    if (dist < radius) {
                        const overlap = radius - dist;
                        if (dist > 0.001) {
                            return new THREE.Vector3((dx/dist)*overlap, 0, (dz/dist)*overlap);
                        } else {
                            return new THREE.Vector3(overlap, 0, 0);
                        }
                    }
                }
            }
            return null;
        }

        function checkCollision2D(position, radius) {
            if (Math.abs(position.x) > 19) return true;
            if (Math.abs(position.z) > 19) return true;
            return getNPCPushOut(position, radius) !== null;
        }

        function hasLineOfSight(from, to) {
            const direction = new THREE.Vector3().subVectors(to, from).normalize();
            const distance = from.distanceTo(to);
            
            for (let obs of obstacles) {
                if (obs.type === 'cylinder') {
                    const toObs = new THREE.Vector3().subVectors(obs.position, from);
                    const proj = toObs.dot(direction);
                    if (proj > 0 && proj < distance) {
                        const closestPoint = new THREE.Vector3().copy(from).addScaledVector(direction, proj);
                        const distToAxis = Math.sqrt(
                            (closestPoint.x - obs.position.x)**2 + 
                            (closestPoint.z - obs.position.z)**2
                        );
                        if (distToAxis < obs.radius + 0.2) {
                            if (closestPoint.y >= obs.yMin && closestPoint.y <= obs.yMax) {
                                return false;
                            }
                        }
                    }
                } else if (obs.type === 'box') {
                    // Ray-AABB intersection (slab method)
                    const boxMin = new THREE.Vector3(
                        obs.position.x - obs.size.x/2,
                        obs.yMin,
                        obs.position.z - obs.size.z/2
                    );
                    const boxMax = new THREE.Vector3(
                        obs.position.x + obs.size.x/2,
                        obs.yMax,
                        obs.position.z + obs.size.z/2
                    );
                    const eps = 1e-8;
                    const dirX = direction.x || eps, dirY = direction.y || eps, dirZ = direction.z || eps;
                    const t1x = (boxMin.x - from.x) / dirX;
                    const t2x = (boxMax.x - from.x) / dirX;
                    const t1y = (boxMin.y - from.y) / dirY;
                    const t2y = (boxMax.y - from.y) / dirY;
                    const t1z = (boxMin.z - from.z) / dirZ;
                    const t2z = (boxMax.z - from.z) / dirZ;
                    const tmin = Math.max(Math.min(t1x,t2x), Math.min(t1y,t2y), Math.min(t1z,t2z));
                    const tmax = Math.min(Math.max(t1x,t2x), Math.max(t1y,t2y), Math.max(t1z,t2z));
                    if (tmax >= Math.max(0, tmin) && tmin < distance) {
                        return false;
                    }
                }
            }
            return true;
        }

        function checkProjectileCollision(prevPos, currentPos, bulletRadius) {
            if (Math.abs(currentPos.x) > 20 || Math.abs(currentPos.z) > 20 || currentPos.y < 0 || currentPos.y > 10) {
                return true;
            }
            
            for (let obs of obstacles) {
                if (obs.type === 'cylinder') {
                    const dx = currentPos.x - obs.position.x;
                    const dz = currentPos.z - obs.position.z;
                    const distHoriz = Math.sqrt(dx*dx + dz*dz);
                    
                    if (distHoriz < obs.radius + bulletRadius) {
                        if (currentPos.y >= obs.yMin && currentPos.y <= obs.yMax) {
                            return true;
                        }
                        const dir = new THREE.Vector3().subVectors(currentPos, prevPos);
                        const len = dir.length();
                        if (len > 0.001) {
                            const toCyl = new THREE.Vector3().subVectors(obs.position, prevPos);
                            const t = toCyl.dot(dir) / (len * len);
                            if (t >= 0 && t <= 1) {
                                const closestPoint = new THREE.Vector3().copy(prevPos).addScaledVector(dir, t * len);
                                const distToAxis = Math.sqrt(
                                    (closestPoint.x - obs.position.x)**2 + 
                                    (closestPoint.z - obs.position.z)**2
                                );
                                if (distToAxis < obs.radius + bulletRadius) {
                                    if (closestPoint.y >= obs.yMin && closestPoint.y <= obs.yMax) {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                } else if (obs.type === 'box') {
                    const boxMin = new THREE.Vector3(
                        obs.position.x - obs.size.x/2,
                        obs.yMin,
                        obs.position.z - obs.size.z/2
                    );
                    const boxMax = new THREE.Vector3(
                        obs.position.x + obs.size.x/2,
                        obs.yMax,
                        obs.position.z + obs.size.z/2
                    );
                    
                    if (currentPos.x + bulletRadius > boxMin.x && currentPos.x - bulletRadius < boxMax.x &&
                        currentPos.y + bulletRadius > boxMin.y && currentPos.y - bulletRadius < boxMax.y &&
                        currentPos.z + bulletRadius > boxMin.z && currentPos.z - bulletRadius < boxMax.z) {
                        return true;
                    }
                    
                    const dir = new THREE.Vector3().subVectors(currentPos, prevPos);
                    const len = dir.length();
                    if (len > 0.001) {
                        const invDir = new THREE.Vector3(1/dir.x, 1/dir.y, 1/dir.z);
                        const t1 = (boxMin.x - prevPos.x) * invDir.x;
                        const t2 = (boxMax.x - prevPos.x) * invDir.x;
                        const t3 = (boxMin.y - prevPos.y) * invDir.y;
                        const t4 = (boxMax.y - prevPos.y) * invDir.y;
                        const t5 = (boxMin.z - prevPos.z) * invDir.z;
                        const t6 = (boxMax.z - prevPos.z) * invDir.z;
                        
                        const tmin = Math.max(Math.min(t1, t2), Math.min(t3, t4), Math.min(t5, t6));
                        const tmax = Math.min(Math.max(t1, t2), Math.max(t3, t4), Math.max(t5, t6));
                        
                        if (tmax >= tmin && tmax >= 0 && tmin <= 1) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // --- ATUALIZAR PROJ√âTEIS ---
        function updateProjectiles(delta) {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                
                p.prevPos.copy(p.mesh.position);
                p.mesh.position.addScaledVector(p.velocity, delta);
                p.life -= 1;
                
                if (checkProjectileCollision(p.prevPos, p.mesh.position, p.radius)) {
                    for (let k = 0; k < 5; k++) {
                        const splatGeo = new THREE.SphereGeometry(0.2, 3);
                        const splatMat = new THREE.MeshStandardMaterial({ 
                            color: p.isSpecial ? 0xffdf00 : (p.shooterTeam === 'green' ? 0x00ff00 : 0xff6b6b)
                        });
                        const splat = new THREE.Mesh(splatGeo, splatMat);
                        splat.position.copy(p.mesh.position);
                        splat.position.x += (Math.random() - 0.5) * 0.5;
                        splat.position.y += Math.random() * 0.5;
                        splat.position.z += (Math.random() - 0.5) * 0.5;
                        scene.add(splat);
                        
                        setTimeout(() => scene.remove(splat), 2000);
                    }
                    
                    scene.remove(p.mesh);
                    projectiles.splice(i, 1);
                    continue;
                }
                
                // Colis√£o com NPCs
                let hit = false;
                for (let j = 0; j < npcs.length; j++) {
                    const npc = npcs[j];
                    if (!npc.active) continue;
                    
                    const dx = p.mesh.position.x - npc.position.x;
                    const dy = p.mesh.position.y - (npc.position.y + 0.8);
                    const dz = p.mesh.position.z - npc.position.z;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    const combinedRadius = p.radius + npc.radius;
                    
                    if (dist < combinedRadius) {
                        hit = true;
                    } else {
                        const dir = new THREE.Vector3().subVectors(p.mesh.position, p.prevPos);
                        const len = dir.length();
                        if (len > 0.001) {
                            const toNPC = new THREE.Vector3().subVectors(npc.position, p.prevPos);
                            toNPC.y += 0.8;
                            const t = toNPC.dot(dir) / (len * len);
                            
                            if (t >= 0 && t <= 1) {
                                const closestPoint = new THREE.Vector3().copy(p.prevPos).addScaledVector(dir, t * len);
                                const distToNPC = closestPoint.distanceTo(npc.position.clone().add(new THREE.Vector3(0, 0.8, 0)));
                                if (distToNPC < combinedRadius) {
                                    hit = true;
                                }
                            }
                        }
                    }
                    
                    if (hit) {
                        npc.health -= 1;
                        
                        if (npc.health <= 0) {
                            npc.active = false;
                            scene.remove(npc.mesh);
                            
                            if (p.shooterTeam === 'green') {
                                if (npc.team === 'pink') {
                                    greenScore += 10;
                                } else if (npc.team === 'green') {
                                    greenScore -= 5;
                                }
                            } else if (p.shooterTeam === 'pink') {
                                if (npc.team === 'green') {
                                    pinkScore += 10;
                                } else if (npc.team === 'pink') {
                                    pinkScore -= 5;
                                }
                            }
                            updateTeamDisplay();
                        } else {
                            npc.mesh.children[0].material.color.setHex(0xffffff);
                            setTimeout(() => {
                                if (npc.active && npc.mesh) {
                                    const originalColor = npc.team === 'green' ? 0x00aa00 : 0xdd3355;
                                    npc.mesh.children[0].material.color.setHex(originalColor);
                                }
                            }, 200);
                        }
                        
                        scene.remove(p.mesh);
                        projectiles.splice(i, 1);
                        break;
                    }
                }
                
                if (hit) continue;
                
                // Colis√£o com jogador (s√≥ se vivo)
                if (player.alive) {
                    const playerCenter = player.position.clone().add(new THREE.Vector3(0, -0.9, 0));
                    const dxP = p.mesh.position.x - playerCenter.x;
                    const dyP = p.mesh.position.y - playerCenter.y;
                    const dzP = p.mesh.position.z - playerCenter.z;
                    const distP = Math.sqrt(dxP*dxP + dyP*dyP + dzP*dzP);
                    const combinedRadiusP = p.radius + player.radius;
                    
                    if (distP < combinedRadiusP) {
                        hit = true;
                    } else {
                        const dir = new THREE.Vector3().subVectors(p.mesh.position, p.prevPos);
                        const len = dir.length();
                        if (len > 0.001) {
                            const toPlayer = new THREE.Vector3().subVectors(playerCenter, p.prevPos);
                            const t = toPlayer.dot(dir) / (len * len);
                            
                            if (t >= 0 && t <= 1) {
                                const closestPoint = new THREE.Vector3().copy(p.prevPos).addScaledVector(dir, t * len);
                                const distToPlayer = closestPoint.distanceTo(playerCenter);
                                if (distToPlayer < combinedRadiusP) {
                                    hit = true;
                                }
                            }
                        }
                    }
                    
                    if (hit) {
                        if (p.shooterTeam !== player.team) {
                            playerHealth -= 1;
                            document.getElementById('player-health-text').textContent = `Vida: ${playerHealth}`;
                            document.getElementById('health-fill').style.width = (playerHealth / 3 * 100) + '%';
                            
                            if (playerHealth <= 0) {
                                player.alive = false;
                                document.getElementById('death-message').style.display = 'block';
                                // Muda a c√¢mera para modo espectador
                                camera.position.set(0, 15, 20);
                                camera.lookAt(0, 0, 0);
                                // Libera o pointer lock para n√£o ficar preso
                                if (document.pointerLockElement) {
                                    document.exitPointerLock();
                                }
                            }
                            
                            updateTeamDisplay();
                        }
                        
                        scene.remove(p.mesh);
                        projectiles.splice(i, 1);
                        continue;
                    }
                }
                
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    projectiles.splice(i, 1);
                }
            }
        }

        // --- CONDI√á√ÉO DE VIT√ìRIA ---
        function checkVictoryCondition() {
            const greenNPCsAlive = npcs.some(n => n.team === 'green' && n.active);
            const pinkNPCsAlive = npcs.some(n => n.team === 'pink' && n.active);
            
            const victoryDiv = document.getElementById('victory-message');
            
            if (!pinkNPCsAlive && (greenNPCsAlive || player.alive)) {
                victoryDiv.style.display = 'block';
                victoryDiv.innerHTML = 'üèÜ TIME VERDE VENCEU! üèÜ';
                victoryDiv.style.color = '#00ff00';
            }
            else if (!greenNPCsAlive && !player.alive && pinkNPCsAlive) {
                victoryDiv.style.display = 'block';
                victoryDiv.innerHTML = 'üèÜ TIME ROSA VENCEU! üèÜ';
                victoryDiv.style.color = '#ff6b6b';
            }
            else if (!greenNPCsAlive && !pinkNPCsAlive && !player.alive) {
                victoryDiv.style.display = 'block';
                victoryDiv.innerHTML = 'ü§ù EMPATE! ü§ù';
                victoryDiv.style.color = '#ffdf00';
            } else {
                victoryDiv.style.display = 'none';
            }
        }

        // --- BOT√ÉO REINICIAR ---
        document.getElementById('restart-button').addEventListener('click', () => {
            projectiles.forEach(p => scene.remove(p.mesh));
            projectiles.length = 0;
            
            resetNPCs();
            
            ammo = maxAmmo;
            document.getElementById('ammo-count').textContent = `${ammo}/${maxAmmo}`;
            
            document.getElementById('victory-message').style.display = 'none';
            document.getElementById('death-message').style.display = 'none';
            
            // Restaura a c√¢mera para o jogador
            camera.position.copy(player.position);
            yaw = 0;
            pitch = 0;
            camera.rotation.set(0, 0, 0);
        });

        // --- ANIMA√á√ÉO ---
        let clock = new THREE.Clock();

        function animate() {
            const delta = Math.min(clock.getDelta(), 0.1);
            
            updatePlayer(delta);
            updateNPCs(delta);
            updateProjectiles(delta);
            
            zoneTiles.forEach((tile, index) => {
                tile.material.emissiveIntensity = 0.2 + Math.sin(Date.now() * 0.005 + index) * 0.1;
            });
            
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>